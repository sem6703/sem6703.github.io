(function (){//test № 1	
const a=[
{ask:' Языки Pascal, BASIC и C являются .... языками, в то время как С++ является объектно-ориентированным языком.',
o:[
'*процедурными',
'линейными',
'функциональными',]},

{ask:' В качестве образца по отношению к объекту выступает:',
o:[
'метод',
'*класс',
'операция',
'значение',]},

{ask:' Двумя основными компонентами объекта являются Данные и функции, которые ???.',
o:[
'приходят и уходят',
'*совершают действия над ними',
'описываются пользователем',]},

{ask:' В C++ функцию, входящую в состав класса, называют:',
o:[
'*функция-член класса',
'оператор класса',
'функция класса',
'метод класса',]},

{ask:' Защита данных от несанкционированного доступа другими функциями называется ...?',
o:[
'Транзакцией',
'Инкапсуляцией',
'*Сокрытием данных',]},


{ask:' Какие из перечисленных ниже причин являются главными для использования объектно-ориентированных языков?',
o:[
'*возможность создания собственных типов данных;',
'простота операторов объектно-ориентированных языков по сравнению с процедурными языками;',
'наличие средств для автокоррекции ошибок в объектно-ориентированных языках;',
'*объектно-ориентированные программы легче концептуализируются.',]},

{ask:' ... отображают объекты реального мира точнее, чем функции.',
o:[
'Художники',
'Кортежи',
'*Объекты',]},

{ask:' Истинно ли утверждение: программа на C++ в целом схожа с программой на C за исключением незначительных различий в кодировании.',
o:[
'*Ложно; организационные принципы различаются',
'Истинно; организационные принципы одинаковы',]},

{ask:' Объединение данных и функций называется ....?',
o:[
'Сокрытие данных',
'*Инкапсуляция',
'Апелляция',]},

{ask:' Если язык обеспечивает возможность создания пользовательских типов данных, то говорят, что язык называется:',
o:[
'наследуемым',
'инкапсулируемым',
'перегруженным',
'*расширяемым',]},

{ask:' Верно или неверно утверждение: двух операторов достаточно, чтобы легко отличить программу на C++ от программы на С.',
o:[
'Истинно; данные одни и теже ',
'*Ложно; большинство строк кода на C++ ничем не отличаются от кода',]},

{ask:' Возможность выполнения оператором или функцией различных действий в зависимости от типа операндов называется ...?',
o:[
'Атрибуцией',
'Интеграцией',
'*Полиморфизмом',]},

{ask:' Операция, выполняющая заданные действия над пользовательским типом данных, называется:',
o:[
'полиморфической;',
'инкапсулированной;',
'классифицированной;',
'*перегруженной.',]},

{ask:' Запоминание новых терминов языка C++:',
o:[
'является очень важным',
'*можно отложить «на потом»',
'служит ключом к успеху и процветанию',
'бессмысленно',]},

{ask:' Универсальный язык моделирования — это:',
o:[
'программа для построения физических моделей',
'*средство визуализации организации программы',
'результат объединения языков C++ и FORTRAN',
'*вспомогательное средство при разработке программного обеспечения',]},

{ask:' Разделение программы на функции:',
o:[
'является ключевым методом объектно-ориентированного программирования',
'*упрощает представление программы',
'*сокращает размер программного кода',
'ускоряет процесс выполнения программы',]},

{ask:' После имени функции ставятся ...?',
o:[
'Фигурные скобки',
'*Круглые скобки',
'Кавычки',]},

{ask:' Тело функции заключается в ...?',
o:[
'*Фигурные скобки',
'Круглые скобки',
'Кавычки',]},

{ask:' В чем особенность функции main()?',
o:[
'*Это первая функция, вызываемая при запуске программы',
'Она вызывается дважды',
'Содержит рекурсивный вызов',]},

{ask:' Конструкция C++, указывающая компьютеру выполнить действие, называется ...?',
o:[
'Процедурой',
'*Выражением',
'Полиморфзмом',]},

{ask:' Напишите пример комментария в стиле C++ и пример устаревшего комментария /*.',
o:[
'*//Это комментарий',
'* /*Это тоже комментарий*/',
'# многострочный комментарий ',]},

{ask:' Выражение:',
o:[
'*всегда приводит к вычислению значения',
'является способом высказывания программы',
'всегда происходит вне функции',
'*является частью оператора',]},

{ask:' Укажите размер переменной типа int в 32-битной системе:',
o:[
'10',
'8',
'6',
'*4',]},

{ask:' Укажите размер переменной типа long double в 32-битной системе:',
o:[
'*10',
'8',
'6',
'4',]},

{ask:' Укажите размер переменной типа float в 32-битной системе:',
o:[
'10',
'8',
'6',
'*4',]},

{ask:' Укажите размер переменной типа long в 32-битной системе:',
o:[
'10',
'8',
'6',
'*4',]},

{ask:' Истинно ли следующее утверждение: переменная типа char может хранить значение 301?',
o:[
'*Ложно',
'Истинно ',]},

{ask:' Укажите, к каким элементам программы относится 12:',
o:[
'*целочисленная константа ',
'символьная константа',
'константа в формате с плавающей запятой',
'имя переменное или идентификатор',
'имя функции',]},

{ask:' Укажите, к каким элементам программы относится &apos;a&apos;:',
o:[
'целочисленная константа',
'*символьная константа ',
'константа в формате с плавающей запятой',
'имя переменное или идентификатор',
'имя функции',]},

{ask:' Укажите, к каким элементам программы относится 4.28915:',
o:[
'целочисленная константа',
'символьная константа',
'*константа в формате с плавающей запятой',
'имя переменное или идентификатор',
'имя функции',]},

{ask:' Укажите, к каким элементам программы относится JungleJim:',
o:[
'целочисленная константа',
'символьная константа',
'константа в формате с плавающей запятой',
'*имя переменное или идентификатор',
'имя функции',]},

{ask:' Укажите, к каким элементам программы относится JungleJim():',
o:[
'целочисленная константа',
'символьная константа',
'константа в формате с плавающей запятой',
'имя переменное или идентификатор',
'*имя функции',]},

{ask:' Напишите оператор, выводящие на экран значение переменной x:',
o:[
'*cout &lt;&lt; &apos;x&apos;;',
'cout &lt;&lt; "Jim";',
'cout &lt;&lt; 509;',
'cout &lt;&lt; x;',]},

{ask:' Истинно ли следующее утверждение: в операции присваивания величина, стоящая слева от знака равенства, всегда равна величине, стоящей справа от знака равенства?',
o:[
'*Ложно; они не равны, пока не выполнится оператор.',
'Истинно ',]},

{ask:' Напишите оператор, выводящий значение переменной george в поле размером 10 символов.',
o:[
'write setw(10)&lt;&lt;george;',
'*cout &lt;&lt;setw(10)&lt;&lt;george;',]},

{ask:' Какой заголовочный файл нужно включить в исходный текст, чтобы использовать объекты cin и cout?',
o:[
'IOMANIP',
'*IOSTREAM',
'SYSTEM',]},

{ask:' Напишите оператор, который получает с клавиатуры числовое значение и присваивает его переменной temp.',
o:[
'*cin >> temp;',
'cout >> temp;',]},

{ask:' Какой заголовочный файл нужно включить в исходный текст, чтобы использовать манипулятор setw?',
o:[
'*IOMANIP',
'IOSTREAM',
'SYSTEM',]},

{ask:' Двумя случаями, когда компилятор обрабатывает разделительные символы, являются ...?',
o:[
'электронные письма',
'*строковые константы',
'*директивы препроцессора',]},

{ask:' Верно или неверно следующее утверждение: нет никаких препятствий к использованию переменных разного типа в одном арифметическом выражении?',
o:[
'Ложно',
'*Истинно',]},

{ask:' Значение выражения 11 % 3 равно ...?',
o:[
'1',
'*2',
'10',]},

{ask:' Действия каких двух типов операций сочетают в себе операции арифметического присваивания?',
o:[
'*Присваивание (=)',
'*арифметические (типа + и *)',
'извлечение логарифма',]},


{ask:' Напишите оператор, увеличивающий значение переменной temp на 23 c одновременным присваиванием. Напишите аналогичный оператор, не использующий сложения с присваиванием.',
o:[
'*temp +=23;',
'*temp =temp +23; ',
'inc(temp,23);',]},


{ask:' На какую величину увеличивает значение переменной операция инкремента?',
o:[
'0',
'*1',]},


{ask:' С какой целью мы включали заголовочные файлы в тексты наших примеров?',
o:[
'*Для обеспечения объявлений и других данных библиотечных функций, перегружаемых операций и объектов.',
'Для вычисления суммы.',]},

{ask:' Коды библиотечных функций содержатся в ... файлах.',
o:[
'*Библиотечных',
'Ипотечных',
'Медийных',]},


{ask:' Операция отношения:',
o:[
'присваивает значение одного операнда другому операнду',
'*имеет своим результатом булево значение',
'*сравнивает значения двух операндов',
'создает логическую комбинацию двух операндов',]},

{ask:' Напишите выражение, использующее операцию отношения, результатом которого является истина, если значения переменных george и sally не равны.',
o:[
'true',
'georg+sally=?',
'*george !=sally',]},

{ask:' Истинным или ложным является значение -1?',
o:[
'ложно; т.к. отрицательно',
'*-1 — истинно; только 0 — ложно',]},


{ask:' Назовите и опишите основное назначение каждого из трех выражений, входящих в состав оператора цикла for.',
o:[
'*Выражение инициализации инициализирует циклическую переменную,выражение опроса переменной тестирует ее, а выражение инкремента — изменяет.',
'Кенгуру носит детеныша в сумке. При виде опасности - убегает.',]},

{ask:' В цикле for, тело которого состоит более чем из одного оператора, точка с запятой ставится после:',
o:[
'обеда',
'оператора цикла for',
'закрывающей фигурной скобки, ограничивающей тело цикла',
'*каждого оператора в теле цикла',
'*условия продолжения цикла',]},

{ask:' Истинно ли следующее утверждение: инкрементирующее выражение цикла может декрементировать счетчик цикла?',
o:[
'Ложно',
'*Истинно',]},

{ask:'7. Создайте цикл for, который будет выводить на экран числа от 100 до 110.',
o:[
'cout &lt;&lt; range(100, 111)',
'* For(int j=00;j<=110;j++)',
'* cout &lt;&lt;endl &lt;&lt;j; ',]},

{ask:' Блок кода ограничен ....',
o:[
'*Фигурными скобками',
'Круглыми скобками',
'Кавычками',]},

{ask:' Переменная, описанная внутри блока, видима:',
o:[
'от точки своего объявления до конца программы',
'от точки своего объявления до конца функции',
'*от точки своего объявления до конца блока',
'внутри функции',]},


{ask:' Истинно ли следующее утверждение: операции отношения имеют более высокий приоритет, чем арифметические операции?',
o:[
'*Ложно',
'Истинно',]},

{ask:' Сколько раз исполняется тело цикла do?',
o:[
'От нуля и выше раз',
'*По крайней мере, один раз',]},




{ask:' Библиотечная функция exit() предназначена для выхода из:',
o:[
'цикла, в котором она содержится;',
'блока, в котором она содержится;',
'функции, в которой она содержится;',
'*программы, в которой она содержится.',]},


{ask:' Библиотечная функция getche();',
o:[
'*возвращает символ в случае нажатия какой-либо из клавиш;',
'возвращает символ в случае нажатия клавиши Enter;',
'*печатает на экране символ, соответствующий нажатой клавише;',
'не отображает символ на экране.',]},

{ask:' Какой символ возвращается объектом cin в том случае, если пользователь нажимает клавишу Enter?',
o:[
'*&apos;\\r&apos;',
'&apos;\\t&apos;',
'&apos;\\n&apos;',]},

{ask:' else всегда соответствует ... if, если только if не заключен в скобки',
o:[
'Последующему',
'*Предшествующему',]},



{ask:' Конструкция else...if получается из вложенных циклов if...else путем ...?',
o:[
'*Переформатирования',
'Размораживания',
'Полиморфизма',]},


{ask:' Напишите оператор с участием условной операции, который присваивал бы переменной ticket значение, равное 1 в том случае, если значение переменной speed больше 55, и 0 в противном случае.',
o:[
'*ticket =(speed >55) ? 1 : 0; ',
'ticket =(speed >55) ? 0 : 1; ',]},

{ask:' Операции && и ||:',
o:[
'сравнивают два численных значения;',
'комбинируют два численных значения;',
'сравнивают два булевых значения;',
'*комбинируют два булевых значения.',]},

{ask:' Напишите выражение с участием логической операции, принимающее истинное значение, если значение переменной limit равно 55, а значение переменной speed превышает 55.',
o:[
'limit !=55 &&speed !=55',
'*limit ==55 &&speed >55',]},

{ask:' Перечислите в порядке убывания приоритетов следующие типы операций: логические, унарные, арифметические, присваивания, отношения, условная операция.',
o:[
'Отношения, условные, присваивание, унарные, арифметические, логические ',
'*Унарные, арифметические, отношения, логические, условные, присваивание',]},


{ask:' Оператор break производит выход:',
o:[
'только из цикла наибольшей глубины вложенности;',
'только из ветвления switch наибольшей глубины вложенности;',
'из всех вложенных циклов и ветвлений;',
'*из цикла или ветвления наибольшей глубины вложенности.',]},

{ask:' Выполнение оператора continue внутри цикла приводит к передаче управления ...?',
o:[
'В конец цикла',
'*В начало цикла',
'В конец программы',]},


{ask:' Оператор goto вызывает переход на:',
o:[
'операцию;',
'*метку;',
'переменную;',
'функцию.',]},


{ask:' Структура объединяет:',
o:[
'данные одного типа',
'*логически связанные данные',
'целые именованные значения',
'*переменные',]},

{ask:' Истинно ли следующее утверждение: структура и класс имеют схожий синтаксис?',
o:[
'Ложно',
'*Истинно',]},

{ask:' После закрывающей фигурной скобки структуры ставится ...?',
o:[
'Восклицательный знак',
'Двоеточие',
'*Точка с запятой',]},


{ask:' Истинно ли следующее утверждение: при определении структуры выделяется память под переменную?',
o:[
'*Ложно; только определение переменной занимает под нее место в памяти.',
'Истинно',]},

{ask:' При обращении к полю структуры левым операндом операции (.) является:',
o:[
'поле структуры;',
'имя структуры;',
'*структурная переменная;',
'ключевое слово struct.',]},

{ask:' Напишите оператор, присваивающий полю hrs структурной переменной time2 значение, равное 11.',
o:[
'*time2.hrs =11;',
'time2.hrs :=11;',
'time2.setValue(11);',]},

{ask:' Сколько байтов памяти займут три структурные переменные типа time, если структура time содержит три поля типа int?',
o:[
'*18 в 16-битных системах (3 структуры на 3 целых числа на 2 байта) или36 в 32-битных системах.',
'24',
'12',]},


{ask:' Истинно ли следующее утверждение: вы можете присвоить значение одной структурной переменной другой структурной переменной того же типа?',
o:[
'Ложно',
'*Истинно',]},

{ask:' Напишите выражение, присваивающее переменной temp значение поля paw структурной переменной fido.',
o:[
'paw:=fido[dogs];',
'*temp =fido,dogs,paw;',]},

{ask:' Перечисление объединяет:',
o:[
'данные различных типов',
'логически связанные переменные',
'*именованные целые числа',
'константные значения',]},




{ask:' Первые три константы перечисляемого типа обычно представляются числами ...?',
o:[
'*0,1,2',
'1,2,3',]},

{ask:' Напишите оператор, в котором объявляется перечисляемый тип speeds с константами obsolete, single и album. Присвойте этим константам целые значения 78, 45 и 33.',
o:[
'enum ={78,45,33}',
'*enum speeds {obsolete=78,single=45,album=33 };',]},



{ask:' Наиболее важным из назначений функции является:',
o:[
'именование блока операторов',
'уменьшение размера программы',
'обработка аргументов и возвращение значения',
'*структуризация программы',]},

{ask:' Код функции задается в ... функции.',
o:[
'*Определении',
'Замыкании',
'Окружении',]},



{ask:' Оператор, описывающий функцию, называется ее ...?',
o:[
'Описателем',
'*Объявлением',
'*прототипом',
'Тело',
'Вызовом',]},

{ask:' Операторы, выполняющие назначение функции, составляют ... функции.',
o:[
'Описателем',
'Объявлением',
'прототипом',
'*Тело',
'Вызовом',]},

{ask:' Оператор, инициирующий выполнение функции, называется ... функции.',
o:[
'Описателем',
'Объявлением',
'прототипом',
'Тело',
'*Вызовом',]},

{ask:' Первая строка в объявлении функции называется ...?',
o:[
'*Описателем',
'Объявлением',
'прототипом',
'Тело',
'Вызовом',]},


{ask:' Аргумент функции — это:',
o:[
'переменная функции, получающая значение из вызывающей программы',
'способ, с помощью которого функция защищает себя от воздействия',
'значений, передаваемых вызывающей программой',
'*значение, передаваемое вызывающей программой в функцию',
'значение, возвращаемое функцией вызывающей программе',]},

{ask:' Истинно ли следующее утверждение: когда аргументы передаются по значению, функция имеет доступ к переменным вызывающей программы?',
o:[
'*Ложно',
'Истинно',]},

{ask:' Для чего предназначена возможность указывать в прототипе функции имена аргументов?',
o:[
'*Для уяснения назначения аргументов',
'Просто так',]},

{ask:' Какие из перечисленных ниже элементов программы можно передавать в функцию:',
o:[
'*константы;',
'*переменные;',
'*структуры;',
'заголовочные файлы.',]},
{ask:' Что означают пустые скобки после имени функции?',
o:[
'*Пустые скобки означают отсутствие аргументов',
'аргумент равен нулю',]},

{ask:' Сколько значений может возвращать функция?',
o:[
'*Один',
'Два',]},

{ask:' Истинно ли следующее утверждение: когда функция возвращает значение, ее вызов можно ставить справа от знака операции присваивания?',
o:[
'Ложно',
'*Истинно',]},

{ask:' Где указывается тип значения, возвращаемый функцией?',
o:[
'*В начале объявления и описателя',
'В прототипе',]},

{ask:' Функция, не возвращающая значения, имеет тип возвращаемого значения',
o:[
'int',
'*void ',]},


{ask:' Когда аргумент передается в функцию по ссылке,',
o:[
'внутри функции создается переменная, хранящая значение этого аргумента;',
'функция не имеет доступа к значению аргумента;',
'в вызывающей программе создается временная переменная для хранения значения аргумента;',
'*функция получает доступ к аргументу в вызывающей программе.',]},

{ask:' Какова причина использования ссылочного механизма передачи аргументов в функцию?',
o:[
'Мутация алгоритмов',
'*Изменение исходного значения аргумента (или желание избежать копирования большого аргумента)',
'Перезагрузка массива',]},

{ask:' Перегруженные функции:',
o:[
'*являются группой функций, имеющих одно и то же имя;',
'имеют одинаковое количество аргументов и их типы;',
'*облегчают процесс программирования;',
'могут не выдержать нагрузки.',]},


{ask:' Как правило, встроенные функции исполняются ... , чем обычные, но занимают больше места в памяти.',
o:[
'Меньше',
'Шире',
'*Быстрее',]},

{ask:' Напишите прототип встроенной функции с именем foobar(), имеющей один аргумент типа float и возвращающей значение типа float.',
o:[
'include float foobar(int int)',
'*inline float foobar(float fvar)',]},

{ask:' Значение аргумента по умолчанию:',
o:[
'*может использоваться вызывающейся программой;',
'*может использоваться функцией;',
'должно быть константой;',
'должно быть значением переменной.',]},

{ask:' Напишите прототип функции с именем blyth(), возвращающей значение типа char и принимающей два аргумента. Первый из аргументов имеет тип int, а второй — тип float и значение по умолчанию, равное 3.14159.',
o:[
'*char blyth(int,float=3.14159);',
'int 5+5=25',]},

{ask:' Область видимости и класс памяти связаны с ...',
o:[
'Инклюзивностью',
'*Видимостью',
'*временем жизни',]},

{ask:' Какие функции могут иметь доступ к глобальной переменной, расположенной в одном файле с ними?',
o:[
'*Функции, определенные после переменных',
'стрелочные',
'void-функции',]},

{ask:' Какие функции имеют доступ к локальной переменной?',
o:[
'Объявленные в области видимости',
'*Те, в которых она определена',
'Рекурсивные',]},

{ask:' Статическая локальная переменная используется для:',
o:[
'расширения области видимости переменной;',
'*ограничения области видимости переменной до одной функции;',
'сохранения переменной в памяти после выполнения функции;',
'*сохранения значения переменной после завершения функции.',]},

{ask:' В каком необычном месте программы можно использовать вызов функции, если эта функция возвращает значение по ссылке?',
o:[
'Внутри блока var',
'*Слева от знака равенства',]},


{ask:' Для чего необходимо определение класса?',
o:[
'*Объявление класса описывает, как будут выглядеть объекты после их создания',
'Определение выделяет место в памяти',]},

{ask:' .... имеет такое же отношение к объекту , как стандартный тип данных к переменной этого типа.',
o:[
'*Класс',
'Экземпляр',
'Массив ',]},

{ask:' В определении класса члены класса с ключевым словом private доступны:',
o:[
'любой функции программы;',
'в случае, если вам известен пароль;',
'*методам этого класса;',
'только открытым членам класса.',]},


{ask:' Истинно ли следующее утверждение: поля класса должны быть закрытыми?',
o:[
'*Ложно; и данные, и функции могут быть как скрытыми, так и общедоступными',
'Истинно',]},


{ask:' Операция точки (операция доступа к члену класса) объединяет следующие два элемента (слева направо):',
o:[
'член класса и объект класса;',
'объект класса и класс;',
'класс и член этого класса;',
'*объект класса и член этого класса.',]},


{ask:' Методы класса, определенные внутри класса, по умолчанию ....',
o:[
'*inline (также и private)',
'_super_',
'*int getcrow()',]},

{ask:' Напишите метод getcrow() для класса Leverage (см. вопрос 4), который будет возвращать значение поля crowbar. Метод следует определить внутри определения класса.',
o:[
'*{return crowbar;} ',
'goto exit;',]},

{ask:' Конструктор вызывается автоматически в момент ....',
o:[
'Запуска программы',
'*Создания (определения) объекта',]},

{ask:' Имя конструктора совпадает с именем ....',
o:[
'*Класса, методом которого он является',
'Прототипа родителя',]},


{ask:' Верно или неверно следующее утверждение: класс может иметь более одного конструктора с одним и тем же именем?',
o:[
'Ложно',
'*Истинно',]},

{ask:' Методу класса всегда доступны данные:',
o:[
'*объекта, членом которого он является;',
'класса, членом которого он является;',
'любого объекта класса, членом которого он является;',
'класса, объявленного открытым.',]},



{ask:' Единственным формальным различием между структурами и классами в С++ является то, что ....',
o:[
'*Методы и данные по умолчанию являются скрытыми в классах, но общедоступными в структурах',
'Память выделяется динамически',]},


{ask:' Пусть определены три объекта класса. Сколько копий полей класса содержится в памяти? Сколько копий методов функций?',
o:[
'*Три, один',
'Один, три',]},

{ask:' Посылка сообщения объекту эквивалентна ....',
o:[
'*Вызову одного из его методов',
'Возвращению результата',]},

{ask:' Классы полезны потому, что:',
o:[
'не занимают памяти, если не используются',
'*защищают свои данные от доступа со стороны других классов',
'*собирают вместе все аспекты, касающиеся отдельной вещи',
'*адекватно моделируют объекты реального мира',]},

{ask:' Истинно ли следующее утверждение: существует простой, но очень точный метод, позволяющий представлять решаемую задачу в виде совокупности объектов классов?',
o:[
'*Ложно; попытки, пусть ошибочные, бывают необходимы',
'Истинно',]},


{ask:' Константный метод, вызванный для объекта класса:',
o:[
'может изменять как неконстантные, так и константные поля;',
'может изменять только неконстантные поля;',
'может изменять только константные поля;',
'*не может изменять как неконстантные, так и константные поля',]},

{ask:' Истинно ли следующее утверждение: объект, объявленный как константный, можно использовать только с помощью константных методов?',
o:[
'Ложно',
'*Истинно',]},

{ask:' Напишите объявление (не определение) функции типа const void с именем aFunc(), которая принимает один константный аргумент jerry типа float',
o:[
'new jerry=float;',
'*void aFunc(const float jerry)const;',]},


{ask:' Доступ к элементам массива осуществляется с помощью:',
o:[
'подхода FIFO;',
'операции точки;',
'имени элемента;',
'*индекса элемента.',]},

{ask:' Все элементы массива должны быть .... типа.',
o:[
'int',
'Простого',
'*Того же',]},


{ask:' Напишите выражение, которое определяет одномерный массив, именованный как doubleArray, типа double, содержащий 100 элементов.',
o:[
'array[0..99]of double;',
'*double doubleArray [100];',]},

{ask:'4. Элементы 10-элементного массива нумеруются начиная ',
o:[
'*с 0 и до 9',
'c 5 до 15',
'с 1 до 11',]},

{ask:' Напишите выражение, которое выводит j элемент массива doubleArray с помощью cout и операции &lt;&lt;.',
o:[
'int &lt;&lt; 1',
'*cout &lt;&lt;doubleArray [j];',]},

{ask:' Какой по счету элемент массива doubleArray[7]?',
o:[
'шестой;',
'седьмой;',
'*восьмой;',
'неизвестно.',]},

{ask:' Напишите выражение, которое определяет массив coins типа int и инициализирует его значениями пенни: 5 центов, 10 центов, 25 центов, 50 центов и 1 доллар.',
o:[
'dim coins={1,5,10,25,50,100 }; ',
'*int coins []={1,5,10,25,50,100 };',]},

{ask:'8. При доступе к многомерному массиву его индексы:',
o:[
'разделены запятыми;',
'заключены в квадратные скобки и разделены запятыми;',
'разделены занятыми и заключены в квадратные скобки;',
'*заключены в квадратные скобки.',]},

{ask:' Напишите выражение для доступа к 4-му элементу 2-го подмассива двумерного массива twoD.',
o:[
'twoD.contain[4]',
'*twoD [2][4]',]},


{ask:' Истинно ли следующее утверждение: в C++ возможна реализация четырехмерного массива?',
o:[
'Ложно',
'*Истинно',]},

{ask:' Для двумерного массива flarr типа float запишите выражение, которое объявляет массив и инициализирует его первый подмассив значениями 52, 27, 83; второй — значениями 94, 73, 49; третий — значениями 3, 6, 1.',
o:[
'a: array of float={{52,27,83},{94,73,49},{3,6,1}};',
'*float flarr [3][3]={{52,27,83},{94,73,49},{3,6,1}};',]}, 

{ask:' Имя массива, используемое в файлах кода, представляет собой .... массива.',
o:[
'Дамп памяти',
'Выражение',
'*Адрес в памяти',]},

{ask:' При передаче имени массива в функцию она:',
o:[
'*работает с тем же массивом, с которым работает и вызывающая функцию программа;',
'работает с копией массива, переданной программой;',
'ссылается на массив, используя то же имя, которое используется в вызывающей программе;',
'*ссылается на массив, используя другое имя, чем то, которое используется в вызывающей программе.',]},

{ask:' Что определяет это выражение? employee emplist [ 1000 ];',
o:[
'Список элементов',
'*Массив из 1000 элементов структуры или класса employee',]},

{ask:' Напишите выражение для доступа к переменной salary структуры, которая является 17-м элементом массива emplist.',
o:[
' [16].salary[emplist]',
'*emplist [16].salary',]},

{ask:' Данные, помещенные в стек первыми:',
o:[
'не имеют индексного номера;',
'имеют индекс, равный 0;',
'будут первыми извлечены из стека;',
'*будут извлечены из стека последними.',]},

{ask:' Напишите выражение, которое определяет массив manybirds, содержащий в себе 50 объектов типа bird.',
o:[
'mouse cat [run]',
'*bird manybirds [50];',]},

{ask:' Истинно ли следующее утверждение: компилятор будет протестовать, если вы попытаетесь получить доступ к 14 элементу массива в 10-элементном массиве?',
o:[
'*Ложно',
'Истинно',]},

{ask:' Напишите выражение, которое вызывает метод cheep() для объекта класса bird, являющегося 27-м элементом массива manybirds.',
o:[
'523453453453',
'*manybirds [26].cheep(); ',]},

{ask:' Строка в C++ — это ....',
o:[
'Хаотичный набор битов',
'*массив типа char',
'Стек с данными',]},

{ask:' Напишите выражение, которое определяет строковую переменную city, содержащую строку длиной до 20 символов (это небольшая хитрость).',
o:[
'*char city [21](Нужен еще один байт для пустого символа.)',
'45465133535',]},

{ask:' Напишите выражение, которое определяет строковую константу dextrose, имеющую значение «C6H1206 - H20».',
o:[
'chip&dail',
'*char dextrose []="6Н1206-Н20 ";',]},

{ask:' Истинно ли следующее утверждение: операция >> прекращает считывание строки при обнаружении пробела?',
o:[
'Ложно',
'*Истинно',]},

{ask:' Вы можете считывать ввод, который содержит несколько строк или текст, используя:',
o:[
'обыкновенную комбинацию cout &lt;&lt;;',
'метод cin.get() с одним аргументом;',
'метод cin.get() с двумя аргументами;',
'*метод cin.get() с тремя аргументами;',
'метод cin.get() с одним аргументом.',]},

{ask:' Напишите выражение, которое использует библиотечную функцию для копирования строки name в строку blank.',
o:[
'strcopy(8,9,x);',
'*strcpy(blank,name)',]},


{ask:' Истинно ли следующее утверждение: предпочтительнее использовать строковый тип вместо стандарного класса string в своих программах?',
o:[
'*Ложно',
'Истинно',]},

{ask:' Объекты класса string:',
o:[
'заканчиваются нулевым символом;',
'*могут быть скопированы с операцией присваивания;',
'*не требуют управления памятью;',
'не имеют методов класса.',]},

{ask:' Напишите выражение, которое осуществляет поиск строки «кот» в строке s1.',
o:[
'789',
'*int n =s1.find("cat");',]},


{ask:' Напишите выражение, которое вставляет строку «кот» в строку s1 на позицию 12.',
o:[
'787',
'*s1.insert(12,"cat ");',]},


{ask:' Перегрузка операций:',
o:[
'*преобразовывает операции(operator) C++ для работы с объектами;',
'предоставляет операциям C++ больше, чем они могут обработать;',
'*дает новое значение существующим в C++ операциям;',
'создает новые операции C++.',]},

{ask:' Предположим, что класс X не использует перегруженные операции. Напишите выражение, в котором вычитается объект x1 класса X из другого объекта x2 этого же класса. Результат помещается в x3.',
o:[
'125',
'*x3.subtract(x2,x1);',]},


{ask:' Истинно ли следующее утверждение: операция >= может быть перегружена?',
o:[
'Ложно',
'*Истинно',]},

{ask:' Запишите полное определение для перегруженной операции в классе Counter программы COUNTPP1, которая вместо увеличения счетчика уменьшает его.',
o:[
'*void operator --(){count--;} ',
'cuper === 0',]},

{ask:' Сколько аргументов требуется для определения перегруженной унарной операции?',
o:[
'2',
'*Нисколько',]},

{ask:' Предположим, что существует класс C с объектами obj1, obj2 и obj3. Выражение obj3=obj1-obj2 работает правильно. Здесь перегруженная операция должна:',
o:[
'принимать два аргумента;',
'*возвращать значение;',
'создавать именованный временный объект;',
'*использовать объект, вызвавший операцию, как операнд.',]},



{ask:' Чем отличается действие перегруженной операции ++ при ее использовании в префиксной форме от использования в постфиксной форме?',
o:[
'*Увеличивает переменную до ее использования как незамещенный оператор ++',
'Делит переменную пополам',]},


{ask:' Истинно ли следующее утверждение: перегруженная операция всегда требует на один аргумент меньше, чем количество операндов?',
o:[
'Ложно',
'*Истинно',]},

{ask:' Когда вы перегружаете операцию арифметического присваивания, то результат:',
o:[
'передается объекту справа от операции;',
'*передается объекту слева от операции;',
'*передается объекту, вызвавшему операцию;',
'должен быть возвращен.',]},


{ask:' Для преобразования от определенного пользователем класса к основному типу вы можете использовать:',
o:[
'встроенную операцию преобразования;',
'конструктор с одним аргументом;',
'перегруженную операцию =;',
'*операцию преобразования, являющуюся членом класса.',]},

{ask:' Истинно ли следующее утверждение: выражение objA=objB будет причиной ошибки компилятора, если объекты разных типов?',
o:[
'*Ложно, если есть программа преобразования; в противном случае истинно',
'Истинно',]},

{ask:' Для преобразования от основного типа к определенному пользователем вы можете использовать:',
o:[
'встроенную операцию преобразования;',
'*конструктор с одним аргументом;',
'перегруженную операцию =;',
'операцию преобразования, являющуюся членом класса.',]},

{ask:' Истинно ли следующее утверждение: если вы определили конструктор, содержащий определение типа aclass obj=intvar;, вы также можете записать выражение типа obj=intvar;?',
o:[
'Ложно',
'*Истинно',]},

{ask:' Если объект objA принадлежит классу A, объект objB принадлежит классу В, вы хотите записать objA=objB и поместить функцию преобразования в класс A, то какой тип процедуры преобразования вы можете использовать?',
o:[
'Деструктор',
'*Конструктор',]},

{ask:' Истинно ли следующее утверждение: компилятор не будет протестовать, если вы перегрузите операцию * для выполнения деления?',
o:[
'Ложно',
'*Истинно, но человеку такое трудно будет понять',]},

{ask:' В диаграммах UML объединение возникает, когда:',
o:[
'в одной программе существуют два класса;',
'один класс происходит от другого;',
'в двух классах используется одна глобальная переменная;',
'*один из классов вызывает метод другого класса.',]},


{ask:' Истинно ли следующее утверждение: у прямоугольников, обозначающих классы, скругленные углы?',
o:[
'*Ложно',
'Истинно',]},

{ask:' Направленность от класса A к классу В означает, что:',
o:[
'*объект класса A может вызвать операцию объекта класса B;',
'существует взаимоотношение между классом A и классом В;',
'объекты могут переходить из класса A в класс В;',
'сообщения из класса B получает класс A',]},


{ask:' Назначение наследования состоит в том, чтобы:',
o:[
'*создавать более общие классы в более специализированных;',
'передавать аргументы объектам классов;',
'*добавлять возможности к существующим классам без их модификации;',
'улучшать сокрытие данных и их инкапсуляцию.',]},

{ask:' Класс-наследник называется ..... от базового класса.',
o:[
'Предком',
'Прототипом',
'*Порожденным',]},

{ask:' Преимущество использования наследования заключается в:',
o:[
'обеспечении развития класса путем естественного отбора;',
'*облегчении создания классов;',
'*избежании переписывания кода;',
'*предоставлении полезной концептуальной основы.',]},

{ask:' Напишите первую строку описания класса Bosworth, который является public-производным класса Alphonso.',
o:[
'Arlecino Colombino',
'*class Bosworth :public Alphonso',]},

{ask:' Будет ли правильным утверждение: создание производного класса требует коренных изменений в базовом классе?',
o:[
'*Утверждение ложно',
'Истинно',]},

{ask:' Члены базового класса для доступа к ним методов производного класса должны быть объявлены как public или ....',
o:[
'virtual',
'static',
'*Скрытые',]},


{ask:' Пусть базовый класс содержит метод basefunc(), а производный класс не имеет метода с таким именем. Может ли объект производного класса иметь доступ к методу basefunc()?',
o:[
'Нет',
'*Да (предполагая, что basefunc не скрыта)',]},


{ask:' Истинно ли следующее утверждение: если конструктор производного класса не определен, то объекты этого класса будут использовать конструкторы базового класса?',
o:[
'Ложно',
'*Истинно',]},

{ask:' Допустим, что базовый и производный классы включают в себя методы с одинаковыми именами. Какой из методов будет вызван объектом производного класса, если не использована операция разрешения имени?',
o:[
'Старший получит право',
'*Тот, который принадлежит порожденному классу',]},


{ask:' Оператор разрешения обычно:',
o:[
'ограничивает видимость переменных для определенных методов;',
'обозначает, от какого базового класса создан производный;',
'*определяет отдельный класс;',
'*разрешает неопределенности.',]},

{ask:' Истинно ли следующее утверждение: иногда полезно создать класс, объектов которого никогда не будет создано?',
o:[
'Ложно',
'*Истинно',]},

{ask:' Предположим, что существует класс Derv, производный от базового класса Base. Напишите объявление конструктора производного класса, принимающего один аргумент и передающего его в конструктор базового класса.',
o:[
'Snowball(0)==create()',
'*Derv(int arg):Base(arg)',]},

{ask:' Предположим, что класс Derv является частным производным класса Base. Мы определяем объект класса Derv, расположенный в функции main(). Через него мы можем получить доступ к:',
o:[
'*членам класса Derv, объявленным как public;',
'членам класса Derv, объявленным как protected;',
'членам класса Derv, объявленным как private;',
'членам класса Base, объявленным как public;',
'членам класса Base, объявленным как protected;',
'членам класса Base, объявленным как private.',]},

{ask:' Истинно ли следующее утверждение: класс D может быть производным класса C, который в свою очередь является производным класса B, который производный класса A?',
o:[
'Ложно',
'*Истинно',]},

{ask:' Иерархия классов:',
o:[
'показывает те же взаимоотношения, что и схема организации;',
'описывает взаимоотношение типа «имеет»;',
'*описывает взаимоотношения типа «является частью»;',
'показывает те же взаимоотношения, что и наследственное дерево.',]},

{ask:' Напишите первую строку описания класса Tire, который является производным классов Wheel и Rubber.',
o:[
'Tire class extends ',
'*class Tire :public Wheel,public Rubber',]},

{ask:' Предположим, что класс Derv является производным класса Base. Оба класса содержат метод func() без аргументов. Напишите выражение, входящее в метод класса Derv, которое вызывает метод func() базового класса.',
o:[
'Baseline:start;',
'*Base::func();',]},
{ask:' Истинно ли следующее утверждение: невозможно сделать объект одного класса, членом, другого класса?',
o:[
'*Ложно',
'Истинно',]},

{ask:' В UML наследование называют ',
o:[
'*Обобщением',
'Замыканием',
'Покаянием',]},

{ask:' Включение — это:',
o:[
'сложная форма реализации;',
'сложная форма обобщения;',
'сложная форма композиции;',
'*взаимоотношение типа «имеет».',]},



{ask:' Истинно ли следующее утверждение: стрелка, представляющая собой обобщение, указывает на более специфичный класс?',
o:[
'*Ложно',
'Истинно',]},

{ask:' Композиция — это ....',
o:[
'Частная фирма кооперации',
'*Сильная форма агрегации',
'Красивая ферма интеграции ',]},


{ask:' Напишите выражение, которое выводит адрес переменной testvar.',
o:[
'cout !== count++;',
'*cout &lt;&lt;&testvar;',]},

{ask:'2. Адреса смежных в памяти переменных типа float отличаются на ....',
o:[
'*4 байта',
'2 байта',]},

{ask:' Указатель — это:',
o:[
'адрес переменной;',
'обозначение переменной, которая будет доступна следующей;',
'*переменная для хранения адреса;',
'тип данных для адресных переменных.',]},


{ask:' Адрес — это Константа, а указатель это — ....',
o:[
'*переменная',
'массив',]},

{ask:' Напишите определение для переменной указателя на float.',
o:[
'*float *ptrtofloat,',
'@ptrtofloat',]},

{ask:' Указатели полезны при ссылке на адреса памяти, которые не имеют ....',
o:[
'*Имени',
'Времени',]},

{ask:' Пусть указатель testptr указывает на переменную testvar. Напишите выражение, которое позволит получить значение переменной testvar, не используя при этом ее имя.',
o:[
'**testptr',
'noname(test)',]},

{ask:' Звездочка, расположенная после типа данных, означает Указатель на. Звездочка, расположенная перед именем переменной, означает ....',
o:[
'прогиб',
'*значение переменной, на которую ссылается указатель',]},

{ask:' Выражение *test означает:',
o:[
'указатель на переменную test;',
'*ссылку на значение переменной test;',
'*разыменование переменной test;',
'*ссылку на значение переменной, на которую указывает test;',]},


{ask:' Указатель на void может содержать указатель на ....',
o:[
'Исходящую переменную',
'*Любой тип данных',]},


{ask:' В чем различие между intarr[3] и (intarr+З)?',
o:[
'Занимает больше памяти',
'*Оба делают одно и то же',]},

{ask:' Пусть intarr массив целых. Почему выражение intarr++ не правильно?',
o:[
'истина содержит ложь',
'*Потому что имя массива — это его адрес, который нельзя изменять',]},


{ask:' Тип переменной, на которую указывает указатель, должен присутствовать в определении указателя для того,',
o:[
'*чтобы типы данных не перемешались при выполнении арифметических операций;',
'чтобы указатель мог быть использован для доступа к членам структуры;',
'чтобы не было затронуто ни одно из религиозных убеждений;',
'*чтобы компилятор мог правильно выполнять арифметические операции и получать доступ к элементам массива.',]},

{ask:' Используя указатели, напишите прототип функции func(), которая возвращает значение типа void и принимает в качестве аргумента массив типа char.',
o:[
'privet',
'*void func(char*);',]},


{ask:' Первый элемент строки это:',
o:[
'имя строки;',
'*первый символ строки;',
'длина строки;',
'имя массива, содержащего строку.',]},

{ask:' Используя указатели, напишите прототип функции revstr(), которая возвращает строку и в качестве аргумента тоже принимает строку.',
o:[
'*char*revstr(char*);',
'counter ==(0);',]},

{ask:' Запишите определение массива numptrs указателей на строки One, Two и Three.',
o:[
'*char*numptrs []={"Один ","Два ","Три "};',
'the one',]},


{ask:' Операция new:',
o:[
'*возвращает указатель на переменную;',
'создает переменную с именем new;',
'*получает память для новой переменной;',
'позволяет узнать, сколько памяти свободно на данный момент.',]},

{ask:' Использование операции new может привести к меньшим .... памяти, чем использование массива.',
o:[
'*Потерям',
'функциям',]},


{ask:' Операция delete возвращает .... операционной системе.',
o:[
'*Память, которая больше не используется',
'строку',]},

{ask:' Пусть нам дан указатель р, указывающий на объект типа upperclass. Напишите выражение, позволяющее вызвать метод exclu() этого класса для данного объекта.',
o:[
'*p->exclu();',
'[p][ex]',]},

{ask:' Пусть дан объект, являющийся элементом массива objarr под номером 7. Напишите выражение, которое позволит вызвать метод exclu() этого объекта,',
o:[
'12',
'*objarr [7].exclu();',]},

{ask:' Связный список — это:',
o:[
'*структура, где каждый элемент представляет собой указатель на следующий элемент;',
'массив указателей, указывающих на элементы списка;',
'*структура, в которой каждый элемент состоит из данных или указателя на данные;',
'структура, в которой элементы хранятся в массиве.',]},

{ask:' Напишите определение массива arr из 8 указателей, которые указывают на переменные типа float.',
o:[
'Array(8).fill(&apos;0&apos;)',
'*float*arr [8];',]},

{ask:' Если мы хотим отсортировать множество больших объектов или структур, то будет более эффективным:',
o:[
'поместить их в массив и сортировать как его элементы;',
'*создать массив указателей на них и отсортировать его;',
'поместить эти объекты в связный список и отсортировать его;',
'поместить ссылки на эти объекты в массив и отсортировать его.',]},

{ask:' Изобразите многообразие объединений, которые имеют до 10 объектов с одной стороны и больше двух — с другой стороны.',
o:[
'*0..9 с одного конца; 3..* — с другого',
'по два с каждого конца',]},

{ask:' Состояния в диаграмме состояний соответствуют:',
o:[
'сообщениям между объектами;',
'*условиям, по которым объекты находят себя;',
'объектам программы;',
'изменениям ситуации, в которой используются объекты.',]},

{ask:' Истинно ли следующее утверждение: переходы между состояниями существуют во время исполнения программы?',
o:[
'*Ложно',
'Истинно',]},

{ask:' Защита в диаграмме состояний — это:',
o:[
'*ограничивающее условие на переход;',
'имя определенного перехода;',
'имя определенного состояния;',
'ограничение на создание определенных состояний',]},

{ask:' Виртуальные функции позволяют:',
o:[
'создавать массивы типа «указатель на базовый класс», которые могут содержать указатели на производные классы;',
'создавать функции, к которым никогда не будет доступа;',
'группировать объекты разных классов так, чтобы они все были доступны с помощью одного и того же вызова функции;',
'*использовать один и тот же вызов функции для выполнения методов объектов, принадлежащих разным классам.',]},

{ask:' Истинно ли утверждение о том, что указатель на базовый класс может ссылаться на объекты порожденного класса?',
o:[
'Ложно',
'*Истинно',]},

{ask:' Пусть указатель р ссылается на объекты базового класса и содержит адрес объекта порожденного класса. Пусть в обоих этих классах имеется невиртуальный метод ding(). Тогда выражение p->ding(); поставит на выполнение версию функции ding() из ....',
o:[
'*Базового класса',
'Виртуального класса',
'Динамического класса',]},

{ask:' Напишите описатель для виртуальной функции dang(), возвращающей результат типа void и имеющей аргумент типа int.',
o:[
'sorgo int(dang dang);',
'*virtual void dang(int);',
'*void virtual dang(int);',]},

{ask:' Принятие решения о том, какая именно функция будет выполняться по конкретному вызову функции, называется ....',
o:[
'*Поздним или динамическим связыванием',
'Запоздалым зажиганием',]},


{ask:' Пусть указатель р ссылается на объекты базового класса и содержит адрес объекта порожденного класса. Пусть в обоих этих классах имеется виртуальный метод ding(). Тогда выражение p->ding(); поставит на выполнение версию функции ding() из ',
o:[
'Последних сил',
'*Порожденного класса',]},

{ask:'7. Напишите описатель чистой виртуальной функции aragorn, не возвращающей значений и не имеющей аргументов.',
o:[
'*virtual void aragorn()=0;',
'aragorn(patronus);',
'*void virtual aragorn()=0; ',]},

{ask:' Чистая виртуальная функция — это виртуальная функция, которая:',
o:[
'*делает свой класс абстрактным;',
'не возвращает результата;',
'*используется в базовом классе;',
'не имеет аргументов.',]},

{ask:' Напишите определение массива parr, содержащего 10 указателей на объекты класса dong.',
o:[
'ding-dong',
'*dong*parr [10];',]},

{ask:' Абстрактный класс используется, когда:',
o:[
'не планируется создавать порожденные классы;',
'есть несколько связей между двумя порожденными классами;',
'*с его помощью запрещено создавать какие-либо объекты;',
'вы хотите отложить объявление класса.',]},

{ask:' Истинно ли утверждение о том, что дружественная функция имеет доступ к скрытым данным класса, даже не являясь его методом?',
o:[
'Ложно',
'*Истинно',]},

{ask:' Дружественная функция может быть использована для того, чтобы:',
o:[
'разные классы могли пользоваться одними аргументами;',
'разрешать доступ к классам, исходный код которых недоступен;',
'*разрешать доступ к несвязанному классу;',
'*увеличить многосторонность применения перегружаемой операции.',]},

{ask:' Напишите описатель дружественной функции harry(), возвращающей результат типа void и имеющей один аргумент класса george.',
o:[
'*friend void harry(george);',
'friend double',]},

{ask:' Ключевое слово friend появляется в:',
o:[
'*классе, разрешающем доступ к другому классу;',
'классе, требующем доступа к другому классу;',
'*разделе скрытых компонентов класса;',
'*разделе общедоступных компонентов класса.',]},

{ask:' Напишите описатель, который в том классе, где он появится, сделает каждый компонент класса harry дружественной функцией.',
o:[
'store friend sally',
'*friend class harry;',
'*friend harry; ',]},

{ask:' Статическая функция:',
o:[
'должна вызываться, когда объект уничтожается;',
'сильно связана с индивидуальным объектом класса;',
'*может быть вызвана с использованием имени класса и имени функции;',
'используется для создания простого объекта.',]},

{ask:' Объясните, что делает по умолчанию оператор присваивания = в применении к объектам.',
o:[
'приближает',
'*выполняет поэлементное копирование',]},

{ask:' Напишите описатель перегружаемой операции присваивания для класса zeta.',
o:[
'*zeta&operator =(zeta&);',
'zet()',]},

{ask:' Оператор присваивания может быть перегружен с целью:',
o:[
'*хранения информации о количестве одинаковых объектов;',
'*присваивания идентификационного номера каждому объекту;',
'проверки того, что все компонентные данные скопировались без ошибок;',
'*уведомления о том, что имело место присваивание.',]},

{ask:' Истинно ли утверждение о том, что пользователь всегда должен определять операцию для конструктора копирования?',
o:[
'*Ложно; компилятор обращается к конструктору по умолчанию',
'Истинно',]},

{ask:' Операции, выполняемые оператором присваивания и конструктором копирования:',
o:[
'*похожи, за исключением того, что конструктор копирования создает новый объект;',
'похожи, за исключением того, что оператор присваивания копирует компонентные данные;',
'различны, за исключением того, что оба создают новый объект;',
'*различны, за исключением того, что оба копируют компонентные данные.',]},

{ask:' Напишите описатель конструктора копирования для класса Bertha.',
o:[
'*Bertha(Bertha&);',
'Bertha.create(Bertha);',]},

{ask:' Истинно ли утверждение о том, что конструктор копирования может быть переопределен с целью копирования только части данных объекта?',
o:[
'Ложно',
'*Истинно, если была причина так делать',]},

{ask:' Продолжительность жизни переменной, которая является:',
o:[
'*локальной по отношению к методу, совпадает с продолжительностью жизни функции;',
'глобальной, совпадает с продолжительностью жизни класса;',
'*нестатическим компонентным данным объекта, совпадает с продолжительностью жизни объекта;',
'статической внутри метода, совпадает с продолжительностью жизни этой функции.',]},

{ask:' Истинно ли утверждение о том, что возврат по значению локальной переменной метода не создает никаких проблем?',
o:[
'Ложно',
'*Истинно; проблема возникает, если оно возвращается по значению',]},


{ask:' Конструктор копирования запускается, когда:',
o:[
'*функция возвращается по значению;',
'*аргумент передается по значению;',
'функция возвращается по ссылке;',
'аргумент передается по ссылке.',]},

{ask:' На что ссылается указатель this?',
o:[
'*На объект, методом которого является функция, использующая его',
'На null',]},

{ask:' Если в заданном классе переменная da является компонентными данными, присвоит ли выражение this.da=37; значение 37 переменной da?',
o:[
'Да',
'*Нет; так как this — указатель, следует использовать this->da=7;',]},

{ask:' Напишите выражение, с помощью которого функция может возвращать весь объект, методом которого она является, без создания временных объектов.',
o:[
'get.all();',
'*return *this;',]},

{ask:' Прямоугольник в объектной диаграмме означает:',
o:[
'общую группу объектов;',
'класс;',
'*экземпляр класса;',
'все объекты класса.',]},

{ask:' Линии между объектами в объектной диаграмме UML называются ....',
o:[
'Ветвями',
'*Связями',]},

{ask:' Истинно ли утверждение о том, что объект A может быть связанным с объектом B только в данный момент и более ни в какой иной?',
o:[
'Ложно',
'*Истинно',]},

{ask:' Объектные диаграммы показывают, какие объекты:',
o:[
'*существуют в данный момент;',
'*взаимодействуют в данный момент;',
'*принимают участие в каких-то действиях в данный момент;',
'имеют операции (методы), вызывающие объекты других классов.',]},

{ask:' Поток C++:',
o:[
'представляет собой поток функционального управления;',
'*представляет собой поток данных из одного места в другое;',
'*ассоциирован с конкретным классом;',
'представляет собой файл.',]},


{ask:' Базовым для большинства потоковых классов является класс ....',
o:[
'*ios',
'android',]},

{ask:' Назовите три потоковых класса, предназначенных для файлового ввода/вывода.',
o:[
'*ifstream',
'*ofstream',
'*fstream',]},

{ask:' Напишите выражение, создающее объект salefile класса ofstream, и ассоциируйте его с файлом SALES.JUN.',
o:[
'shutdown',
'*ofstream salefile ("SALES.JUN "); ',]},

{ask:' Истинно ли утверждение о том, что некоторые потоки являются входными, а некоторые — выходными?',
o:[
'Ложно',
'*Истинно',]},

{ask:' Напишите if, определяющий, достиг объект ifstream под названием foobar конца файла или же возникла ошибка.',
o:[
'*if(foobar)',
'then(foobar)',]},

{ask:' Мы можем выводить текст в объект класса ofstream с использованием оператора вставки &lt;&lt; потому, что:',
o:[
'класс ofstream — это поток;',
'оператор вставки работает с любыми классами;',
'на самом деле вывод осуществляется в cout;',
'*оператор вставки перегружен в ofstream.',]},

{ask:' Напишите выражение, записывающее единичный символ в объект fileOut класса ofstream.',
o:[
'rect(i,i,i,i);',
'*fileOut.put(ch);(где ch - символ) ',]},

{ask:' Для записи данных, содержащих переменные типа float, в объект типа ofstream необходимо использовать:',
o:[
'оператор вставки;',
'seekg();',
'*write();',
'put(). ',]},

{ask:' Напишите выражение, считывающее содержимое объекта ifile класса ifstream,в массив buff.',
o:[
'readln(f,n);',
'*ifile.read((char*)buff.sizeof(buff)); ',]},

{ask:' Биты режимов, такие, как app и ate:',
o:[
'*определяются в классе ios;',
'*могут устанавливать, для чтения или для записи открыт файл;',
'работают с функциями put() и get();',
'*устанавливают режимы открытия файлов.',]},

{ask:' Дайте определение термину текущая позиция в контексте работы с файлами.',
o:[
'*Расположение байта, который будет читаться или записываться следующим',
'Позиция равная нулю',]},

{ask:'13. Истинно ли утверждение о том, что файловый указатель всегда содержит адрес файла?',
o:[
'*Ложно; файловый указатель может быть синонимом текущей позиции',
'Истинно',]},

{ask:' Напишите выражение, сдвигающее текущую позицию на 13 байтов назад в потоковом объекте f1.',
o:[
'shl(f1,13);',
'*f1.seekg(-l3,ios::cur); ',]},

{ask:' Выражение f1.write( (chav*)&obj1, sizeof(obj1));:',
o:[
'записывает методы obj1 в f1;',
'*записывает данные obj1 в f1;',
'записывает методы и данные obj1 в f1;',
'записывает адрес obj1 в f1.',]},

{ask:' Аргументы командной строки:',
o:[
'это разборки в армии;',
'*набираются после названия программы в командной строке;',
'*делаются доступными с помощью аргументов main();',
'доступны только дисковым файлам.',]},

{ask:' Что означает флаг skipws при его использовании с cin?',
o:[
'*skipws приводит к тому, что символы-разделители игнорируются при вводе, поэтому cin не воспринимает окончание ввода',
'вывод потока',]},

{ask:' Напишите описатель для main(), позволяющий программе распознавать аргументы командной строки.',
o:[
'goodday',
'*int main(int argc,char *argv [])',]},

{ask:' В консольных программах доступ к принтеру осуществляется с помощью зарезервированного имени ....',
o:[
'CON',
'KBRD',
'*PRN, LPT1',]},

{ask:' Напишите описатель перегруженного оператора >>, который берет данные из объекта класса istream и выводит их как данные объекта класса Sample. ',
o:[
'istream&.Sample.write(data)',
'*istream&operator >>(istream&.Sample&) ',]},

{ask:' Разбивать программу на несколько файлов желательно, потому что:',
o:[
'*некоторые файлы не нуждаются в перекомпиляции при каждой сборке;',
'*программа может быть разделена на функциональные элементы;',
'*файлы можно представлять на рынке в объектном виде;',
'*разные программисты могут работать над разными файлами.',]},

{ask:' Заголовочный файл связывается с исходным с помощью ....',
o:[
'*Директивы #include',
'ios',]},



{ask:' Объектный файл присоединяется к исходному с помощью ....',
o:[
'*Компилятора для компилирования .cpp файла и компоновщика для связывания с .OBJ файлами',
'клея',]},

{ask:' В файл проекта включаются:',
o:[
'*данные о содержимом файлов, входящих в проект;',
'*даты последних изменений файлов, входящих в проект;',
'команды компиляции и компоновки;',
'определения переменных C++.',]},

{ask:' Группу связанных между собой классов, поставляющуюся в виде отдельного программного продукта, часто называют ....',
o:[
'Букетом Абхазии',
'*Библиотекой класса',]},

{ask:' Истинно ли утверждение о том, что заголовочный файл может нуждаться в доступе со стороны нескольких исходных файлов в проекте?',
o:[
'Ложно',
'*Истинно',]},

{ask:' Так называемые скрытые файлы библиотеки классов:',
o:[
'требуют пароль;',
'могут быть сделаны доступными с помощью дружественных функций;',
'*помогают защитить код от пиратов;',
'*могут состоять только из объектного кода.',]},

{ask:' Истинно ли утверждение о том, что библиотеки классов — это более мощный инструмент, чем библиотеки функций?',
o:[
'Ложно',
'*Истинно',]},

{ask:' Истинно ли утверждение о том, что интерфейс является скрытой частью библиотеки, а реализация — общедоступной?',
o:[
'*Ложно',
'Истинно',]},

{ask:' Общедоступная часть библиотеки классов обычно содержит:',
o:[
'*объявления методов;',
'определения методов;',
'*объявления классов;',
'*определения небольших функций.',]},

{ask:' Два или более исходных файла могут быть соединены путем их ....',
o:[
'Компиляции',
'*Связывания',]},

{ask:' Истинно ли утверждение о том, что переменная, определенная внутри функции, видна на протяжении всего исходного текста того файла, в котором она определена?',
o:[
'*Ложно',
'Истинно',]},

{ask:' Глобальная переменная определена в файле A. Чтобы получить доступ к ней из файла B, необходимо:',
o:[
'определить ее в файле B, используя extern;',
'определить ее в файле B, используя static;',
'расслабиться (ничего не надо делать);',
'*объявить ее в файле B, используя extern.',]},

{ask:' Часть программы, в которой к данной переменной имеют доступ переменные из других частей программы, называется ....',
o:[
'*Областью видимости',
'Передней частью',]},

{ask:' Файлы, которые реально соединяются компоновщиком, называются ....',
o:[
'*Объектными',
'Метрами',]},

{ask:' Функция определена в файле A. Для того чтобы можно было вызывать ее из файла B, функция должна быть ',
o:[
'Полезна',
'*Объявлена в файле B',]},

{ask:' Истинно ли утверждение о том, что объявление функции не требует использования extern?',
o:[
'Ложно',
'*Истинно',]},

{ask:' Чтобы определять объекты класса в разных файлах, в каждом из них необходимо:',
o:[
'объявлять класс;',
'*определять класс;',
'объявлять класс с использованием extern;',
'определять класс с использованием extern.',]},

{ask:' Истинно ли утверждение о том, что переменная, определенная в заголовочном файле, может быть доступна из двух исходных файлов, если в каждый из них включен этот заголовочный файл?',
o:[
'*Ложно',
'Истинно',]},

{ask:' Конструкция #if !defined()...#endif может использоваться для предотвращения повторных определений, когда:',
o:[
'два заголовочных файла включены в исходный файл;',
'заголовочный файл включен в два исходных;',
'два заголовочных файла включены в два исходных;',
'*один заголовочный файл включен в другой, и оба они включены в исходный.',]},

{ask:' Пространства имен используются для:',
o:[
'автоматизации именования переменных;',
'*сужения области видимости элементов программы;',
'разделения программы на отдельные файлы;',
'предотвращения использования длинных имен переменных.',]},

{ask:' Для определения пространства имен используется формат, сходный с определением класса, но вместо зарезервированного слова class используется ....',
o:[
'object',
'*namespace',]},

{ask:' Использование typedef позволяет:',
o:[
'сокращать длинные имена переменных;',
'*менять имена типов;',
'сокращать длинные названия функций;',
'*менять названия классов.',]},


{ask:' Шаблоны позволяют удобным способом создавать семейства:',
o:[
'переменных;',
'*функций;',
'*классов;',
'программ.',]},

{ask:' Шаблонный аргумент всегда начинается с ключевого слова ',
o:[
'*class',
'privat',]},

{ask:' Истинно ли утверждение о том, что шаблоны автоматически создают разные версии класса в зависимости от введенных пользователем данных?',
o:[
'*Ложно; различные функции создаются в процессе компиляции',
'Истинно',]},


{ask:' Шаблонный класс:',
o:[
'создается для того, чтобы храниться в разных контейнерах;',
'*работает с разными типами данных;',
'генерирует идентичные объекты;',
'генерирует классы с различным числом методов.',]},

{ask:' Истинно ли утверждение о том, что шаблон может иметь несколько аргументов?',
o:[
'Ложно',
'*Истинно',]},

{ask:' Создание реальной функции из шаблона называется .... функции.',
o:[
'Перегрузкой',
'*Реализацией',]},

{ask:' Реальный код шаблонной функции генерируется при:',
o:[
'объявлении функции в исходном коде;',
'определении функции в исходном коде;',
'*вызове функции в исходном коде;',
'запуске функции во время работы программы.',]},

{ask:' Ключевой для шаблонов является концепция, согласно которой Фиксированный тип данных заменяется на имя, которое подставляется вместо ....',
o:[
'*произвольного типа данных',
'указателя',]},

{ask:' Шаблоны часто используются с классами, которые ....',
o:[
'*Хранят данные',
'Хранят код',]},


{ask:' Исключение в большинстве случаев возникает из-за:',
o:[
'программиста, написавшего исходный код приложения;',
'создателя класса, написавшего его методы;',
'*ошибки выполнения;',
'сбоя в операционной системе.',]},

{ask:' При работе с механизмом исключений в C++ используются следующие ключевые слова: ',
o:[
'*try',
'*catch',
'*throw',]},

{ask:' Напишите выражение, генерирующее исключение, используя класс BoundsError (тело класса пусто).',
o:[
'before(null);',
'*throw BoundsError();',]},

{ask:' Истинно ли утверждение о том, что выражения, котрые могут создать исключительную ситуацию, должны быть частью блока-ловушки?',
o:[
'*Ложно; они должны быть частью блока повторных попыток',
'Истинно',]},

{ask:' Исключения передаются:',
o:[
'из блока-ловушки в блок повторных попыток;',
'из выражения, создавшего исключительную ситуацию, в блок повторных попыток;',
'из точки, где возникла ошибка, в блок-ловушку;',
'*из выражения, в котором возникла ошибка, в блок-ловушку.',]},


{ask:' Истинно ли утверждение о том, что выражение, генерирующее исключение, не должно быть расположено в блоке повторных попыток?',
o:[
'*Ложно',
'Истинно',]},



{ask:' Для следующих ошибок обычно генерируется исключение:',
o:[
'*чрезмерное количество данных грозит переполнить массив;',
'пользователь нажал Ctrl+C для закрытия программы;',
'скачок напряжения в сети привел к перезагрузке системы;',
'*new не может зарезервировать необходимый объем памяти.',]},

{ask:' Дополнительная информация, передающаяся при генерации исключения, может быть помещена в:',
o:[
'ключевое слово throw;',
'функцию, вызвавшую ошибку;',
'блок-ловушку;',
'*объект класса исключений.',]},

{ask:' Истинно ли утверждение о том, что программа может продолжить свое выполнение после возникновения исключительной ситуации?',
o:[
'Ложно',
'*Истинно',]},


{ask:' Шаблонный класс показывается на диаграмме UML в виде:',
o:[
'*обычного класса с каким-то аппендиксом;',
'пунктирной линии;',
'прямоугольника с пунктирным контуром;',
'нет правильного ответа.',]},

{ask:' Истинно ли утверждение о том, что зависимость — это вид ассоциации?',
o:[
'*Ложно',
'Истинно',]},

{ask:' Стереотип дает ....',
o:[
'*Дополнительную информацию об элементе UML.',
'возможность передумать',]},


{ask:' Контейнер STL используется для:',
o:[
'*хранения объектов класса employee;',
'*хранения элементов таким образом, что доступ к ним осуществляется с крайне высокой скоростью;',
'компилирования программ на C++;',
'*организации определенного способа хранения данных в памяти.',]},

{ask:' Перечислите последовательные контейнеры STL.',
o:[
'*Вектор, список, очередь с двусторонним доступом',
'файл, поток',]},

{ask:' Двумя особо важными ассоциативными контейнерами STL являются ....',
o:[
'*Множество',
'Список',
'*отображение',]},

{ask:' Алгоритм STL — это:',
o:[
'*независимая функция для работы с контейнерами;',
'связующий элемент между методами и контейнерами;',
'функция, дружественная соответствующим классам контейнеров;',
'метод соответствующих контейнеров.',]},

{ask:' Истинно ли утверждение о том, что одной из функций итераторов STL является связывание алгоритмов и контейнеров?',
o:[
'Ложно',
'*Истинно',]},

{ask:' Алгоритм find();',
o:[
'осуществляет поиск подходящих последовательностей элементов в двух контейнерах;',
'осуществляет поиск контейнера, соответствующего указанному;',
'*в качестве первых двух аргументов использует итераторы;',
'в качестве первых двух аргументов использует элементы контейнера.',]},

{ask:' Истинно ли утверждение о том, что алгоритмы могут использоваться только с контейнерами STL?',
o:[
'*Ложно',
'Истинно',]},

{ask:' Диапазон часто задается в алгоритме двумя значениями типа ....',
o:[
'Множество',
'*Итераторов',]},

{ask:' Какая сущность зачастую используется для изменения поведения алгоритма?',
o:[
'Итератор',
'*Функциональный объект',]},

{ask:' Вектор является подходящим контейнером, если вы:',
o:[
'собираетесь вставлять множество новых элементов в произвольные места контейнера;',
'собираетесь вставлять новые элементы всегда в начало или конец контейнера;',
'*имеете индекс и хотите получить быстрый доступ к элементу с этим индексом;',
'имеете ключевое значение элемента и хотите получить быстрый доступ к элементу по этому ключу.',]},

{ask:' Истинно ли утверждение о том, что метод back() удаляет элементы из конца контейнера?',
o:[
'*Ложно; он просто возвращает значение',
'Истинно',]},


{ask:' Алгоритм unique() удаляет все ....  элементы из контейнера.',
o:[
'Пустые',
'*Дублирующие',]},

{ask:' В очереди с двусторонним доступом:',
o:[
'данные можно быстро вставлять (и удалять) в любую позицию;',
'*данные можно вставлять (удалять) в произвольную позицию, но это процесс относительно долгий;',
'*данные можно быстро вставлять (удалять) в концы очереди;',
'данные можно вставлять (удалять) в концы очереди, но это процесс относительно долгий.',]},

{ask:' В итераторе ....',
o:[
'*Указывается на конкретный элемент контейнера.',
'хранится граф',]},

{ask:' Истинно ли утверждение о том, что итератор всегда может сдвигаться как в прямом, так и в обратном направлении по контейнеру?',
o:[
'*Ложно',
'Истинно',]},

{ask:' Необходимо использовать, по крайней мере, .... итератор для работы со списком.',
o:[
'Рекурсивный',
'*Двунаправленный',]},

{ask:' Пусть iter — это итератор контейнера. Напишите выражение, имеющее значением объект, на который ссылается iter, и заставляющее затем сдвинуться iter на следующий элемент контейнера.',
o:[
'**iter++',
'hola(amigo)',]},

{ask:' Алгоритм copy() возвращает итератор на:',
o:[
'последний элемент, из которого производилось копирование;',
'последний элемент, в который производилось копирование;',
'элемент, располагающийся после последнего элемента, из которого производилось копирование;',
'*элемент, располагающийся после последнего элемента, в который производилось копирование.',]},

{ask:' Для того, чтобы использовать reverse_iterator, необходимо:',
o:[
'начать с инициализации его значением end();',
'начать с инициализации его значением rend();',
'*инкрементировать его для сдвига назад по контейнеру;',
'декрементировать его для сдвига назад по контейнеру.',]},

{ask:' Истинно ли утверждение о том, что итератор back_inserter всегда приводит к тому, что новый элемент вставляется вслед за существующими?',
o:[
'Ложно',
'*Истинно',]},

{ask:' Потоковые итераторы позволяют рассматривать файлы, а также такие устройства, как дисплей и клавиатура, в качестве .... ',
o:[
'*Итераторов',
'Строк',]},

{ask:' Что задает второй аргумент ostream_iterator?',
o:[
'*Это строка, используемая для разделения выводимых значений',
'Вектор определенный в файле',]},

{ask:' В ассоциативном контейнере:',
o:[
'значения хранятся в упорядоченном (отсортированном) виде;',
'*ключи упорядочены;',
'сортировка всегда производится в алфавитном порядке или по возрастанию числовых значений;',
'необходимо использовать алгоритм sort() для сортировки.',]},


{ask:' Истинно ли утверждение о том, что во множестве метод insert() добавляет ключи с одновременной их сортировкой?',
o:[
'Ложно',
'*Истинно',]},


{ask:' Истинно ли утверждение о том, что отображение может иметь два и более элементов с одинаковыми ключами?',
o:[
'*Ложно',
'Истинно',]},

{ask:' Если в контейнере хранятся не объекты, а указатели на них, то;',
o:[
'*объекты не будут копироваться при их добавлении в контейнер;',
'могут использоваться только ассоциативные контейнеры;',
'невозможна сортировка по каким-либо атрибутам объекта;',
'*контейнеры будут занимать меньше памяти.',]},

{ask:' Если вы хотите, чтобы ассоциативный контейнер типа set производил автоматическую сортировку своих значений, можно определить порядок сортировки специальным функциональным объектом и указать его в числе ',
o:[
'Итераторов',
'*Конструкторов контейнера',]},


{ask:' Истинно ли утверждение о том, что прецедентный подход связан, прежде всего, с определением используемых в классе методов?',
o:[
'*Ложно',
'Истинно',]},

{ask:' Варианты использования (кроме всего прочего) нужны для:',
o:[
'получения сведений о проблемах, возникших в программном коде;',
'того, чтобы узнать, какие в классах могут быть конструкторы;',
'*обеспечения выбора подходящих атрибутов класса;',
'*определения того, какие классы необходимы в программе.',]},

{ask:' Вариант использования — это, на самом деле, ....',
o:[
'*Действие',
'Истина',]},

{ask:' Истинно ли утверждение о том, что после создания диаграммы вариантов использования новые варианты использования можно добавлять уже после начала написания кода программы?',
o:[
'Ложно',
'*Истинно',]},

{ask:' Описание вариантов использования иногда пишется в двух ',
o:[
'*Колонках',
'Паттернах',]},

{ask:' Действующим субъектом может быть:',
o:[
'*некая система, взаимодействующая с нашей;',
'некая программная сущность, помогающая разработчику решить конкретную проблему при кодировании;',
'*человек, взаимодействующий с разрабатываемой системой;',
'проектировщик системы.',]},

{ask:' Классы могут связываться между собой с помощью .....',
o:[
'*Ассоциации ',
'*обобщения',
'*агрегации',]},

{ask:' Водопадный процесс:',
o:[
'*состоит из различных этапов;',
'никогда реально не использовался;',
'стал непригоден в связи с нехваткой воды;',
'*может протекать только в одном направлении.',]},

{ask:' Истинно ли утверждение о том, что UML используется только совместно с Унифицированным процессом?',
o:[
'*Ложно',
'Истинно',]},

{ask:' Классы в программе могут соответствовать:',
o:[
'*существительным в описаниях вариантов использования;',
'вариантам использования;',
'ассоциациям в диаграммах UML;',
'именам знаменитых программистов.',]},

{ask:' Истинно ли утверждение о том, что невнятные, общие сущности (например, такие, как «система») описаний вариантов использования должны исключаться из кандидатов в классы?',
o:[
'Ложно',
'*Истинно',]},

{ask:' Истинно ли утверждение о том, что сущности с единственным атрибутом и не имеющие методов являются хорошими кандидатами в классы?',
o:[
'*Ложно',
'Истинно',]},

{ask:' Что может происходить время от времени в Унифицированном процессе:',
o:[
'*диаграмма вариантов использования рисуется до того, как становятся известны все варианты использования;',
'*диаграмма классов рисуется до того, как написаны некоторые описания вариантов использования;',
'*часть кода может быть написана до окончания работы над диаграммой классов;',
'*заголовочный файл с объявлениями классов изменяется одновременно с написанием тел методов.',]},


{ask:' Контейнерные классы STL в программе LANDLORD:',
o:[
'нельзя использовать, так как их невозможно отобразить на диаграмме вариантов использования;',
'*являются подходящим местом для хранения данных о расходах;',
'нельзя использовать, так как C++ является объектно-ориентированным языком;',
'являются подходящим местом для хранения скрытых тел методов.',]},

{ask:' Определения методов:',
o:[
'следует помещать в заголовочные файлы;',
'*не следует помещать в заголовочные файлы;',
'*вероятно, не должны предоставляться пользователям;',
'обычно предоставляются пользователям.',]},

{ask:' Истинно ли утверждение о том, что атрибуция является одним из основных видов взаимосвязи между классами?',
o:[
'*Ложно',
'Истинно',]},

{ask:' Пусть имеется ассоциативная связь между классами A и B, Пусть objA —объект класса A, a objB — объект класса B, Тогда:',
o:[
'*objA может послать сообщение objB;',
'класс В должен быть подклассом класса A или наоборот;',
'objB должен быть атрибутом класса A или наоборот;',
'objB может помочь objA выполнить задачу.',]},

{ask:' В программе LANDLORD используется',
o:[
'обобщение;',
'*ассоциация;',
'интерсубординация;',
'*агрегация.',]},

{ask:' Истинно ли утверждение о том, что на диаграмме классов ассоциация показана в виде отношения между объектами?',
o:[
'*Ложно',
'Истинно',]},

{ask:' В диаграмме последовательностей:',
o:[
'время идет слева направо;',
'ассоциации идут справа налево;',
'*горизонтальные стрелки представляют собой сообщения;',
'*вертикальные пунктирные линии представляют собой линию жизни.',]},

{ask:' Диаграмма последовательностей показывает сообщения одних .... другим.',
o:[
'*Объектов',
'Потоков',]},

{ask:' Истинно ли утверждение о том, что диаграмма последовательностей часто описывает только один вариант использования?',
o:[
'Ложно',
'*Истинно',]},

{ask:' При создании нового класса на диаграмме последовательностей:',
o:[
'*рисуется прямоугольник с его именем на соответствующей высоте;',
'большой буквой X отмечается этот момент времени;',
'с этого места начинается блок активности;',
'*начинается его линия жизни.',]},

];	
	const au=document.querySelector('.a2');	
	const k1=document.querySelector('#k1');	
	const tst=au.querySelector('.tst');
	const scat=document.querySelectorAll('.a2, .overlay');
	const cr2js=document.querySelector('.cr2js');
	cr2js.addEventListener('click',()=>{[...scat].forEach(x=>x.classList.toggle('hidden'))});	
	k1.addEventListener('click',()=>{[...scat].forEach(x=>x.classList.toggle('hidden'))});	
	fn(au,a);
	
})();